'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _output = require('cli-engine-command/lib/output');

var _output2 = _interopRequireDefault(_output);

require('cli-engine-config');

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _plugins = require('./plugins');

var _plugins2 = _interopRequireDefault(_plugins);

var _legacy = require('./plugins/legacy');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = class {

  constructor({ config, out }) {
    this.config = config;
    this.out = out;
  }

  async generateCommandsCache() {
    const flatten = require('lodash.flatten');
    try {
      const plugins = await new _plugins2.default(this.out).list();
      const cmds = await Promise.all(plugins.map(async p => {
        const hydrated = await p.pluginPath.require();
        const cmds = hydrated.commands || [];
        return cmds.filter(c => !c.hidden).map(c => {
          const Command = typeof c === 'function' ? c : (0, _legacy.convertFromV5)(c);
          const publicFlags = Object.keys(Command.flags || {}).filter(flag => !Command.flags[flag].hidden).map(flag => `--${flag}`).join(' ');
          const flags = publicFlags.length ? ` ${publicFlags}` : '';
          const namespace = p.namespace ? `${p.namespace}:` : '';
          const id = Command.command ? `${Command.topic}:${Command.command}` : Command.topic;
          return `${namespace}${id}${flags}`;
        });
      }));
      const commands = flatten(cmds).join('\n');
      _fsExtra2.default.writeFileSync(_path2.default.join(this.config.cacheDir, 'completions', 'commands'), commands);
    } catch (e) {
      this.out.debug('Error creating autocomplete commands');
      this.out.debug(e.message);
    }
  }
};